1. CREATE PROJECT
a. Create a folder to the project.
b. Create folders inside the project: Client & Server
c. Create a project in each folder using: dotnet new console --use-program-main
d. Client: Change name from program.cs to LoginRegistration.cs, and create a new file called Chattis.cs. (First we had one called "Logic", but to structure better we divided it into two)

2. CREATE SERVER
a. Used Williams poll example to be able to connect multiple clients.

3. CREATE CLIENT THAT CONNECTS TO THE SERVER
a. Based of Williams poll server.

4. CLIENT-LoginRegistration.
a. Create a class USER that contains UserName and Password.
b. Create Main Menu.
c. Create functionality to create an account.
d. Function to send the New User information to the Server.

5.ACCOUNT CREATION: RECIEVE & PROCESS INFORMATION FROM THE CLIENT 
a. SERVER: Recieve the new user information.
KOMM.(Tog bort dubletter, servern blev forvirrad nar den fick en "Hej Server" ist for CREATE_ACCOUNT med 2 delar anv och losen)
b. SERVER sends a confirmation response to the client.
5.b CLIENT: Recieved the response and print out that the user is created.
c. SERVER: Console prints out a message: Console.WriteLine($"Creating account for user: {username} with password: {password}");

6. SERVER: MONGODB 
a. Download in terminal: dotnet add package MongoDB.Driver
b. Added Using keyword for MongoDB
c. Created a container in Docker Desktop called ChatApp - assigned a port(Was'nt bound port automatically causing the code not contiued because no connection wiht DB. Wee needed to create a new one through images, choose play-optional setting-type in the port in the input field). 
d. Initiated a collection called users & Bson Docker: static IMongoCollection<BsonDocument> usersCollection;
e.  // Set up MongoDB connection
        MongoClient mongoClient = new MongoClient("mongodb://localhost:27017");
        IMongoDatabase database = mongoClient.GetDatabase("ChatApp");
        usersCollection = database.GetCollection<BsonDocument>("users");
f. Created a function InsertUser to save user and user info to the Database. 
g. Called the function InsertUser in the CREATE_ACCOUNT switch.

7. CREATE LOGIN FUNCTION
a. CHANGED, it now has it's own Switch.-CLIENT LogIn function & a new Case for Login
b. CLIENT: Function SendLoginInformation to send Login information to the server.
c. SERVER: Added LOGIN case to handle the data coming in through "LOGIN".
d. Created a function for Authenticate User, that checks if there is a user with given username & password. 
e. We call on that function in an IF statement in the case"LOGIN".
f. If succecfull, send a confirmation response "Login successfull to the client. If not send a message to the user saying Login failed. 

8. CREATED FUNCTIONALITY TO HANDLE IF LOGIN FAILED OR SUCCEEDED
a. Created a function to handle the response from the server, if failed, the Main menu displays again. 

9. CLIENT: SPLIT LOGIC FILE
a. One for Login&Registration and another for once you are logged in in the Chatroom.

10. CLIENT: UPDATE CREATE ACCOUNT FUNCTION 
a. Created a function for handleCreateAccountResponse, with a Switch depending on what answer the CLient recieves from the Server: ACCOUNT_CREATED or ACCOUNT_CREATION_FAILED"
b. We call on handleCreateAccountResponse in "SendAccountInformation"

11.SERVER:  CREATED FUNCTIONALITY TO CHECK IF USERNAME EXISTS
a. SERVER: If username exists, Account fails and CLIENT:user is directed to main menu. If it dont exists, the account is created  and user is directed to main menu.
b. SERVER Calling on that function in CREATE_ACCOUNT Case.

12. CREATED LISTS
a. For connectedClients - when a client connected-adds to list.
b. For loggedInClients- when a user logs in-adds to list.
c. In LOGOUT-Removes the client from the loggedInClients and the connectedClients.
d. Send the ConnectedClientsList to the Client.
e. Client recieves the list in the general "response" var in Main(client).

13. RESPONSE HANDLE ERROR- when a client is logged in, the connected/logged in users displays for the first person that logs in.
when the second user logs in, it comes invalid server response. We solved this by creating separate response variables instead of "response", we have now "loginRespone", "createAccountResponse", and we are planning on doing the same for logout, public messages, and private messages. 

14. CREATES SPECIFIC RESPONSE VARIABLE FOR CONNECTED CLIENTS.
a. Created a "HandleConnectedClientsResponse".
b. Adjusted the server SendConnectedClientsList to include a Prefix to tell the client that this is a ConnectedClients Response.

15. 
a. Created "Chattis Meny" class.^
b. Calling ChattisMeny in case "LOGIN_SUCCESSFUL"
c. Since the connectedclients list was sent immidiatly when a user connects, I had to create a function to specifically request for that list SendConnectedClientsList. 
!! Now it worked for the first user loggin in. But for the second user it got an unexpected response in HandleLoginResponse. So I realized that the program got confused about the response. 
d. So i decided to take away the automatic sending of the list when each users connect(server), and then specifically asking for it upon login(The same as when the user request the list)

16. LOG OUT FUNCTION
a. Client: Added SendLogoutRequest to send the request to the server. 
b. Client: Added HandleLogOutResponse to handle the response from the server. 
c. Server: Added a case&response for "LOGOUT" to send a response to the client & removes the user from the lists of logged in users. 
d. Client: Call the SendLogoutRequest in the menu option for Logout. 

17. Added messageCollection to MongoDB
a. Intitilize 
b. Created function to add message(woth fromUser& toUSer) to the Database
c. Added a case for SEND_MESSAGE and responses


Justee: Tell that if a user disconneccts it schould be marked as a logout in the server? 


NEXT STEP:
First check what's added and what you think about the call commands. 
1. Show "this person joined" to everyone when a user logs in. 

3. Show "this person left" to everyone when a user logs out/leave. 
4. Functionality for public messages. (showing "you" on the person who send it and username for everyone else)
5. Functionality for private messages.

OK Show this menu function-call that in the menu option for show menu.
OK  Show Logged in users-call the connected users list in the menu option.
 
Loopa igenom connected clients list skicka medd till dem,  kalla pa funktion i Login successfull -Ta emot svar i clienten.
  

WE only have one thread thats why only one thin at once


Functionality Storage: 
Create a variable called "privateMessages" with a parameter of which 2 users it schould be saved to.(?)Send the messages to the server that handles the storage in mongodb. 
Same thing with "publicMessages" thats saved to all users. 



Everytime someone enters the chatroom, server needs to send the last 30 messeges of that room->the client needs to recive them and display them. 

Each time a message is sent, it updates the server with the new message. The message that is 31 messages back will get deleted for each new message in that room. 

spara medd till anvandare-varje anv har en egen list. Nar man skickar proivat mmedd sparar man medd privat pa den anvandaren.
spara allt i en collection-variabel kopplar till anvandare. Globalt el privat- om privat pekar till anv med ex id. 


OK Registrera användare (med namn och lösenord minst)

OK Logga in på chat-appen (med namn och lösenord)
 Informera alla användare som redan är inloggade (e.g. <user> har loggat in!)

Skicka meddelande till andra användare som också är inloggade
	- Alla ser allas meddelanden

Skicka privat meddelande till en annan användare
	- Ingen annan kan se meddelandet

Se historik på meddelande (upp till 30 meddelanden)
	- Historiken visas så fort man loggar in
	- Globala och privata meddelanden skall visas

IF WE GOT TIME:
- The character "|" can't be allowed in the user inputs since the system will split everything
- när man får upp listan på alla som är inloggade, exkludera den currenuser 

I server - säg att alla inloggade ska få meddelandet om vem som loggat in-loopa igenom connectedclients
	- ta emot meddelande i klienten

För meddelanden - samma princip som för ’senduserinformation’

server tar emot meddelande - skickar tillbaka meddelande och skickar med username - i client-välj att utesluta eget namn